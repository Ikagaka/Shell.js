!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Shell=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Shell;

Shell = (function() {
  var $, Nar, Promise, Surface, SurfaceUtil, SurfacesTxt2Yaml, URL, _;

  _ = window["_"];

  $ = window["jQuery"];

  SurfacesTxt2Yaml = window["SurfacesTxt2Yaml"];

  Nar = window["Nar"] || require("ikagaka.nar.js");

  Surface = window["Surface"] || require("./Surface.js");

  SurfaceUtil = window["SurfaceUtil"] || require("./SurfaceUtil.js");

  Promise = window["Promise"];

  URL = window["URL"];

  function Shell(directory) {
    if (!directory["descript.txt"]) {
      throw new Error("descript.txt not found");
    }
    this.directory = directory;
    this.descript = Nar.parseDescript(Nar.convert(this.directory["descript.txt"].asArrayBuffer()));
    this.surfaces = null;
  }

  Shell.prototype.load = function(callback) {
    var buffer, mergedSurfaces, surfaces, surfacesTxt;
    if (!!this.directory["surfaces.txt"]) {
      buffer = this.directory["surfaces.txt"].asArrayBuffer();
      surfacesTxt = Nar.convert(buffer);
      surfaces = Shell.parseSurfaces(surfacesTxt);
    } else {
      surfaces = {
        "surfaces": {}
      };
    }
    mergedSurfaces = Shell.mergeSurfacesAndSurfacesFiles(surfaces, this.directory);
    return Shell.loadSurfaces(mergedSurfaces, (function(_this) {
      return function(err, loadedSurfaces) {
        return Shell.loadElements(loadedSurfaces, _this.directory, function(err, loadedElmSurfaces) {
          if (!!err) {
            return callback(err);
          }
          _this.surfaces = Shell.createBases(loadedElmSurfaces);
          return callback(null);
        });
      };
    })(this));
  };

  Shell.prototype.attachSurface = function(canvas, scopeId, surfaceId, callback) {
    var hits, srfs, type, _ref, _ref1, _surfaceId;
    if (callback == null) {
      callback = function() {};
    }
    type = scopeId === 0 ? "sakura" : "kero";
    if (Array.isArray((_ref = this.surfaces.aliases) != null ? (_ref1 = _ref[type]) != null ? _ref1[surfaceId] : void 0 : void 0)) {
      _surfaceId = Number(SurfaceUtil.choice(this.surfaces.aliases[type][surfaceId]));
    } else {
      _surfaceId = surfaceId;
    }
    srfs = this.surfaces.surfaces;
    hits = Object.keys(srfs).filter(function(name) {
      return Number(srfs[name].is) === _surfaceId;
    });
    if (hits.length === 0) {
      return null;
    }
    return new Surface(canvas, scopeId, hits[0], this.surfaces, callback);
  };

  Shell.createBases = function(surfaces) {
    var srfs;
    srfs = surfaces.surfaces;
    Object.keys(srfs).forEach(function(name) {
      var baseSurface, cnv, elms, sortedElms, srfutil;
      srfs[name].is = srfs[name].is;
      cnv = srfs[name].baseSurface;
      if (!srfs[name].elements) {
        return srfs[name].baseSurface = cnv;
      } else {
        elms = srfs[name].elements;
        sortedElms = Object.keys(elms).map(function(key) {
          return {
            is: Number(elms[key].is),
            x: Number(elms[key].x),
            y: Number(elms[key].y),
            canvas: elms[key].canvas,
            type: elms[key].type
          };
        }).sort(function(elmA, elmB) {
          if (elmA.is > elmB.is) {
            return 1;
          } else {
            return -1;
          }
        });
        baseSurface = sortedElms[0].canvas || srfs[name].baseSurface;
        srfutil = new SurfaceUtil(baseSurface);
        srfutil.composeElements(sortedElms);
        return srfs[name].baseSurface = baseSurface;
      }
    });
    return surfaces;
  };

  Shell.loadSurfaces = function(surfaces, callback) {
    var promises, srfs;
    srfs = surfaces.surfaces;
    promises = Object.keys(srfs).filter(function(name) {
      return !!srfs[name].file;
    }).map(function(name) {
      return new Promise(function(resolve, reject) {
        return setTimeout(function() {
          var buffer, url;
          buffer = srfs[name].file.asArrayBuffer();
          url = URL.createObjectURL(new Blob([buffer], {
            type: "image/png"
          }));
          return SurfaceUtil.loadImage(url, function(err, img) {
            URL.revokeObjectURL(url);
            if (!!err) {
              return reject(err);
            }
            srfs[name].baseSurface = SurfaceUtil.transImage(img);
            return resolve();
          });
        });
      });
    });
    Promise.all(promises).then(function() {
      return callback(null, surfaces);
    })["catch"](function(err) {
      console.error(err, err.stack);
      return callback(err, null);
    });
    return void 0;
  };

  Shell.loadElements = function(surfaces, directory, callback) {
    var promises, srfs;
    srfs = surfaces.surfaces;
    promises = Object.keys(srfs).filter(function(name) {
      return !!srfs[name].elements;
    }).reduce((function(arr, srfName) {
      return arr.concat(Object.keys(srfs[srfName].elements).map(function(elmName) {
        var elm;
        elm = srfs[srfName].elements[elmName];
        return new Promise(function(resolve, reject) {
          return setTimeout(function() {
            var buffer, file, type, url, x, y;
            type = elm.type, file = elm.file, x = elm.x, y = elm.y;
            if (!directory[file]) {
              file += ".png";
            }
            if (!directory[file]) {
              reject(new Error(file.substr(0, file.length - 4) + "element file not found"));
            }
            buffer = directory[file].asArrayBuffer();
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return SurfaceUtil.loadImage(url, function(err, img) {
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err.error);
              }
              elm.canvas = SurfaceUtil.transImage(img);
              return resolve();
            });
          });
        });
      }));
    }), []);
    Promise.all(promises).then(function() {
      return callback(null, surfaces);
    })["catch"](function(err) {
      console.error(err, err.stack);
      return callback(err, null);
    });
    return void 0;
  };

  Shell.mergeSurfacesAndSurfacesFiles = function(surfaces, directory) {
    return Object.keys(directory).filter(function(filename) {
      return /^surface\d+\.png$/i.test(filename);
    }).map(function(filename) {
      return [Number((/^surface(\d+)\.png$/i.exec(filename) || ["", "-1"])[1]), directory[filename]];
    }).reduce((function(surfaces, _arg) {
      var file, n, name, srfs;
      n = _arg[0], file = _arg[1];
      name = "surface" + n;
      srfs = surfaces.surfaces;
      if (!srfs[name]) {
        srfs[name] = {
          is: "" + n
        };
      }
      srfs[name].file = file;
      srfs[name].baseSurface = null;
      return surfaces;
    }), surfaces);
  };

  Shell.parseSurfaces = function(text) {
    var data;
    data = SurfacesTxt2Yaml.txt_to_data(text);
    data.surfaces = Object.keys(data.surfaces).reduce((function(obj, name) {
      if (typeof data.surfaces[name].is === "string") {
        obj[name] = data.surfaces[name];
      }
      if (Array.isArray(data.surfaces[name].base)) {
        data.surfaces[name].base.forEach(function(key) {
          return data.surfaces[name] = $.extend(true, data.surfaces[name], data.surfaces[key]);
        });
      }
      return obj;
    }), {});
    return data;
  };

  return Shell;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Shell;
}

if (window["Ikagaka"] != null) {
  Ikagaka["Shell"] = Shell;
}

},{"./Surface.js":2,"./SurfaceUtil.js":3,"ikagaka.nar.js":4}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Surface;

Surface = (function() {
  var $, Promise, SurfaceUtil, _;

  $ = window["jQuery"];

  _ = window["_"];

  SurfaceUtil = window["SurfaceUtil"] || require("./SurfaceUtil.js");

  Promise = window["Promise"];

  function Surface(element, scopeId, surfaceName, surfaces, callback) {
    var srf;
    this.element = element;
    this.scopeId = scopeId;
    this.surfaceName = surfaceName;
    this.surfaces = surfaces;
    if (callback == null) {
      callback = function() {};
    }
    srf = this.surfaces.surfaces[surfaceName];
    this.baseSurface = srf.baseSurface;
    this.regions = srf.regions || {};
    this.animations = srf.animations || {};
    this.bufferCanvas = SurfaceUtil.copy(this.baseSurface);
    this.stopFlags = {};
    this.layers = {};
    this.destructed = false;
    this.talkCount = 0;
    this.talkCounts = {};
    $(this.element).on("contextmenu", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("click", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("dblclick", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDoubleClick", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousedown", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mousemove", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("mouseup", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchmove", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseMove", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchend", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseUp", function($ev) {
          return $(_this.element).trigger($ev);
        });
      };
    })(this));
    $(this.element).on("touchstart", (function(_this) {
      return function() {
        var touchOnce;
        touchOnce = false;
        return function(ev) {
          touchOnce = !touchOnce;
          if (touchOnce) {
            Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function($ev) {
              return $(_this.element).trigger($ev);
            });
            return setTimeout((function() {
              return touchOnce = false;
            }), 500);
          }
        };
      };
    })(this)());
    Object.keys(this.animations).forEach((function(_this) {
      return function(name) {
        var animationId, interval, n, pattern, tmp, _is, _ref;
        _ref = _this.animations[name], _is = _ref.is, interval = _ref.interval, pattern = _ref.pattern;
        animationId = Number(_is);
        interval = interval || "";
        tmp = interval.split(",");
        interval = tmp[0];
        n = Number(tmp.slice(1).join(","));
        switch (interval) {
          case "sometimes":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 2);
          case "rarely":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), 4);
          case "random":
            return Surface.random((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "periodic":
            return Surface.periodic((function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            }), n);
          case "always":
            return Surface.always(function(callback) {
              if (!_this.destructed && !_this.stopFlags[animationId]) {
                return _this.play(animationId, callback);
              }
            });
          case "runonce":
            return _this.play(animationId, callback);
          case "never":
            break;
          case "bind":
            break;
          case "yen-e":
            break;
          case "talk":
            return _this.talkCounts[name] = n;
          default:
            if (/^bind(?:\+(\d+))/.test(interval)) {

            }
            return console.error(_this.animations[name]);
        }
      };
    })(this));
    this.render();
  }

  Surface.prototype.destructor = function() {
    SurfaceUtil.clear(this.element);
    $(this.element).off();
    this.destructed = true;
    this.layers = {};
    return void 0;
  };

  Surface.prototype.YenE = function() {
    return Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].interval === "yen-e" && _this.talkCount % _this.talkCounts[name] === 0;
      };
    })(this)).forEach((function(_this) {
      return function(name) {
        return _this.play(Number(_this.animations[name].is));
      };
    })(this));
  };

  Surface.prototype.talk = function() {
    this.talkCount++;
    return Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return /^talk/.test(_this.animations[name].interval) && _this.talkCount % _this.talkCounts[name] === 0;
      };
    })(this)).forEach((function(_this) {
      return function(name) {
        return _this.play(Number(_this.animations[name].is));
      };
    })(this));
  };

  Surface.prototype.render = function() {
    var patterns, srfs, util, util2;
    srfs = this.surfaces.surfaces;
    patterns = Object.keys(this.layers).sort(function(layerNumA, layerNumB) {
      if (Number(layerNumA) > Number(layerNumB)) {
        return 1;
      } else {
        return -1;
      }
    }).map((function(_this) {
      return function(key) {
        return _this.layers[key];
      };
    })(this)).reduce(((function(_this) {
      return function(arr, pat) {
        var hits, surface, type, x, y;
        surface = pat.surface, type = pat.type, x = pat.x, y = pat.y;
        if (surface === "-1") {
          return arr;
        }
        hits = Object.keys(srfs).filter(function(key) {
          return srfs[key].is === surface;
        });
        if (hits.length === 0) {
          return arr;
        }
        return arr.concat({
          type: type,
          x: Number(x),
          y: Number(y),
          canvas: srfs[hits[hits.length - 1]].baseSurface
        });
      };
    })(this)), []);
    SurfaceUtil.clear(this.bufferCanvas);
    util = new SurfaceUtil(this.bufferCanvas);
    util.composeElements([
      {
        "type": "base",
        "canvas": this.baseSurface
      }
    ].concat(patterns));
    SurfaceUtil.clear(this.element);
    util2 = new SurfaceUtil(this.element);
    util2.init(this.bufferCanvas);
    return void 0;
  };

  Surface.prototype.play = function(animationId, callback) {
    var anim, hits;
    if (callback == null) {
      callback = function() {};
    }
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return Number(_this.animations[name].is) === animationId;
      };
    })(this));
    if (hits.length === 0) {
      setTimeout(callback);
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    anim.patterns.map((function(_this) {
      return function(pattern) {
        return function() {
          return new Promise(function(resolve, reject) {
            var a, animId, arr, b, match, surface, type, wait, __, _ref, _ref1, _ref2;
            surface = pattern.surface, wait = pattern.wait, type = pattern.type;
            if (/^start\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.play(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^stop\,\d+/.test(type)) {
              animId = Number(type.split(",")[1]);
              _this.stop(animId, function() {
                return resolve();
              });
              return;
            }
            if (/^alternativestart\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref[0], match = _ref[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.play(animId, function() {
                  return resolve();
                });
                return;
              }
            }
            if (/^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.test(type)) {
              _ref1 = /^alternativestop\,[\(\[](\d+(?:\[\,\.]\d+)*)[\)\]]/.exec(type), __ = _ref1[0], match = _ref1[1];
              arr = match.split(/[\,\.]/);
              if (arr.length > 0) {
                animId = Number(SurfaceUtil.choice(arr));
                _this.stop(animId);
                resolve();
                return;
              }
            }
            _this.layers[anim.is] = pattern;
            _this.render();
            _ref2 = /(\d+)(?:\-(\d+))?/.exec(wait), __ = _ref2[0], a = _ref2[1], b = _ref2[2];
            if (b != null) {
              wait = _.random(Number(a), Number(b));
            }
            return setTimeout((function() {
              if (_this.destructed) {
                return reject();
              } else {
                return resolve();
              }
            }), wait);
          });
        };
      };
    })(this)).reduce((function(proA, proB) {
      return proA.then(proB);
    }), Promise.resolve()).then((function(_this) {
      return function() {
        return setTimeout(callback);
      };
    })(this))["catch"](function(err) {
      return console.error(err.stack);
    });
    return void 0;
  };

  Surface.prototype.stop = function(animationId) {
    this.stopFlags[animationId] = true;
    return void 0;
  };

  Surface.prototype.bind = function(animationId) {
    var anim, animIds, hits, interval, pattern;
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return Number(_this.animations[name].is) === animationId;
      };
    })(this));
    if (hits.length === 0) {
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    if (anim.patterns.length === 0) {
      return void 0;
    }
    interval = anim.interval;
    pattern = anim.patterns[anim.patterns.length - 1];
    this.layers[anim.is] = pattern;
    this.render();
    if (/^bind(?:\+(\d+))/.test(interval)) {
      animIds = interval.split("+").slice(1);
      animIds.forEach((function(_this) {
        return function(animId) {
          return _this.play(animId, function() {});
        };
      })(this));
    }
    return void 0;
  };

  Surface.prototype.unbind = function(animationId) {
    delete this.layers[animationId];
    return void 0;
  };

  Surface.processMouseEvent = function(ev, scopeId, regions, eventName, callback) {
    var detail, left, offsetX, offsetY, top, _ref;
    _ref = $(ev.target).offset(), left = _ref.left, top = _ref.top;
    if (/^touch/.test(ev.type)) {
      offsetX = ev.originalEvent.changedTouches[0].pageX - left;
      offsetY = ev.originalEvent.changedTouches[0].pageY - top;
    } else {
      offsetX = ev.pageX - left;
      offsetY = ev.pageY - top;
    }
    $(ev.target).css({
      "cursor": "default"
    });
    if (Surface.isHit(ev.target, offsetX, offsetY)) {
      ev.preventDefault();
      detail = Surface.createMouseEvent(eventName, scopeId, regions, offsetX, offsetY);
      if (!!detail["Reference4"]) {
        $(ev.target).css({
          "cursor": "pointer"
        });
      } else {
        $(ev.target).css({
          "cursor": "default"
        });
      }
      if (ev.button === 2) {
        detail["Reference5"] = 1;
      }
      callback($.Event('IkagakaSurfaceEvent', {
        detail: detail,
        bubbles: true
      }));
    }
    return void 0;
  };

  Surface.createMouseEvent = function(eventName, scopeId, regions, offsetX, offsetY) {
    var event, hits;
    event = {
      "ID": eventName,
      "Reference0": offsetX | 0,
      "Reference1": offsetY | 0,
      "Reference2": 0,
      "Reference3": scopeId,
      "Reference4": "",
      "Reference5": 0
    };
    hits = Object.keys(regions).slice().sort(function(a, b) {
      if (a.is > b.is) {
        return 1;
      } else {
        return -1;
      }
    }).filter(function(name) {
      var bottom, left, right, top, _ref;
      _ref = regions[name], name = _ref.name, left = _ref.left, top = _ref.top, right = _ref.right, bottom = _ref.bottom;
      return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
    });
    if (hits.length !== 0) {
      event["Reference4"] = regions[hits[hits.length - 1]].name;
    }
    return event;
  };

  Surface.random = function(callback, n) {
    var ms;
    ms = 1;
    while (Math.round(Math.random() * 1000) > 1000 / n) {
      ms++;
    }
    return setTimeout((function() {
      return callback(function() {
        return Surface.random(callback, n);
      });
    }), ms * 1000);
  };

  Surface.periodic = function(callback, n) {
    return setTimeout((function() {
      return callback(function() {
        return Surface.periodic(callback, n);
      });
    }), n * 1000);
  };

  Surface.always = function(callback) {
    return callback(function() {
      return Surface.always(callback);
    });
  };

  Surface.isHit = function(canvas, x, y) {
    var ctx, data, imgdata;
    ctx = canvas.getContext("2d");
    imgdata = ctx.getImageData(0, 0, x + 1, y + 1);
    data = imgdata.data;
    return data[data.length - 1] !== 0;
  };

  return Surface;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Surface;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Surface"] = Surface;
}

},{"./SurfaceUtil.js":3}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var SurfaceUtil;

SurfaceUtil = (function() {
  function SurfaceUtil(cnv) {
    this.cnv = cnv;
    this.ctx = this.cnv.getContext("2d");
  }

  SurfaceUtil.prototype.composeElements = function(elements) {
    var canvas, copyed, offsetX, offsetY, type, x, y, _ref;
    if (elements.length === 0) {
      return;
    }
    _ref = elements[0], canvas = _ref.canvas, type = _ref.type, x = _ref.x, y = _ref.y;
    offsetX = offsetY = 0;
    switch (type) {
      case "base":
        this.base(canvas, offsetX, offsetY);
        break;
      case "overlay":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "overlayfast":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "replace":
        this.replace(canvas, offsetX + x, offsetY + y);
        break;
      case "add":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "bind":
        this.overlayfast(canvas, offsetX + x, offsetY + y);
        break;
      case "interpolate":
        this.interpolate(canvas, offsetX + x, offsetY + y);
        break;
      case "move":
        offsetX = x;
        offsetY = y;
        copyed = SurfaceUtil.copy(this.cnv);
        this.base(copyed, offsetX, offsetY);
        break;
      default:
        console.error(elements[0]);
    }
    this.composeElements(elements.slice(1));
    return void 0;
  };

  SurfaceUtil.prototype.base = function(part, x, y) {
    SurfaceUtil.clear(this.cnv);
    this.overlayfast(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.overlayfast = function(part, x, y) {
    this.ctx.globalCompositeOperation = "source-over";
    this.ctx.drawImage(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.interpolate = function(part, x, y) {
    this.ctx.globalCompositeOperation = "destination-over";
    this.ctx.drawImage(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.replace = function(part, x, y) {
    this.ctx.clearRect(x, y, part.width, part.height);
    this.overlayfast(part, x, y);
    return void 0;
  };

  SurfaceUtil.prototype.init = function(cnv) {
    this.cnv.width = cnv.width;
    this.cnv.height = cnv.height;
    this.overlayfast(cnv, 0, 0);
    return void 0;
  };

  SurfaceUtil.choice = function(ary) {
    return ary[Math.round(Math.random() * (ary.length - 1))];
  };

  SurfaceUtil.clear = function(cnv) {
    cnv.width = cnv.width;
    return void 0;
  };

  SurfaceUtil.copy = function(cnv) {
    var copy, ctx;
    copy = document.createElement("canvas");
    ctx = copy.getContext("2d");
    copy.width = cnv.width;
    copy.height = cnv.height;
    ctx.drawImage(cnv, 0, 0);
    return copy;
  };

  SurfaceUtil.transImage = function(img) {
    var a, b, cnv, ctx, data, g, i, imgdata, r;
    cnv = SurfaceUtil.copy(img);
    ctx = cnv.getContext("2d");
    imgdata = ctx.getImageData(0, 0, img.width, img.height);
    data = imgdata.data;
    r = data[0], g = data[1], b = data[2], a = data[3];
    i = 0;
    if (a !== 0) {
      while (i < data.length) {
        if (r === data[i] && g === data[i + 1] && b === data[i + 2]) {
          data[i + 3] = 0;
        }
        i += 4;
      }
    }
    ctx.putImageData(imgdata, 0, 0);
    return cnv;
  };

  SurfaceUtil.loadImage = function(url, callback) {
    var img;
    img = new Image;
    img.src = url;
    img.addEventListener("load", function() {
      return callback(null, img);
    });
    img.addEventListener("error", function(ev) {
      console.error(ev);
      return callback(ev.error, null);
    });
    return void 0;
  };

  return SurfaceUtil;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = SurfaceUtil;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["SurfaceUtil"] = SurfaceUtil;
}

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Nar;

Nar = (function() {
  var Encoding, JSZip, URL, WMDescript, XMLHttpRequest;

  XMLHttpRequest = window["XHRProxy"];

  Encoding = window["Encoding"];

  JSZip = window["JSZip"];

  WMDescript = window["WMDescript"];

  URL = window["URL"];

  function Nar() {
    this.directory = null;
    this.install = null;
  }

  Nar.prototype.loadFromBuffer = function(buffer, callback) {
    this.directory = Nar.unzip(buffer);
    if (!this.directory["install.txt"]) {
      return callback(new Error("install.txt not found"));
    }
    return setTimeout((function(_this) {
      return function() {
        _this.install = Nar.parseDescript(Nar.convert(_this.directory["install.txt"].asArrayBuffer()));
        return callback(null);
      };
    })(this));
  };

  Nar.prototype.loadFromURL = function(src, callback) {
    return Nar.wget(src, "arraybuffer", (function(_this) {
      return function(err, buffer) {
        if (!!err) {
          return callback(err);
        }
        return _this.loadFromBuffer(buffer, callback);
      };
    })(this));
  };

  Nar.prototype.loadFromBlob = function(blob, callback) {
    var url;
    url = URL.createObjectURL(blob);
    return this.loadFromURL(url, function(err) {
      URL.revokeObjectURL(url);
      return callback(err);
    });
  };

  Nar.prototype.grep = function(regexp) {
    return Object.keys(this.directory).filter(function(path) {
      return regexp.test(path);
    });
  };

  Nar.prototype.getDirectory = function(regexp) {
    return this.grep(regexp).reduce(((function(_this) {
      return function(dir, path, zip) {
        dir[path.replace(regexp, "")] = _this.directory[path];
        return dir;
      };
    })(this)), {});
  };

  Nar.unzip = function(buffer) {
    var zip;
    zip = new JSZip();
    zip.load(buffer);
    return Object.keys(zip.files).reduce((function(dic, filePath) {
      var path;
      path = filePath.split("\\").join("/");
      dic[path] = zip.files[filePath];
      return dic;
    }), {});
  };

  Nar.convert = function(buffer) {
    return Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), 'UNICODE', 'AUTO'));
  };

  Nar.wget = function(url, type, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener("load", function() {
      if (200 <= xhr.status && xhr.status < 300) {
        if (!!xhr.response.error) {
          return callback(new Error(xhr.response.error.message), null);
        } else {
          return callback(null, xhr.response);
        }
      } else {
        return callback(new Error(xhr.status), null);
      }
    });
    xhr.open("GET", url);
    xhr.responseType = type;
    xhr.send();
    return void 0;
  };

  Nar.parseDescript = function(text) {
    return WMDescript.parse(text);
  };

  return Nar;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Nar;
}

if (window["Ikagaka"] != null) {
  window["Ikagaka"]["Nar"] = Nar;
}

},{}]},{},[1])(1)
});