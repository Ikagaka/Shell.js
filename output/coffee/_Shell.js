// Generated by CoffeeScript 1.9.2
(function() {
  cuttlebone.Shell = (function() {
    function Shell(directory) {
      this.directory = directory;
      this.descript = null;
      this.surfaces = null;
    }

    Shell.prototype.load = function() {
      var hits, keys, prm, surfaces;
      if (!!this.directory["descript.txt"]) {
        this.descript = cuttlebone.Util.parseDescript(cuttlebone.Util.convert(this.directory["descript.txt"]));
      } else {
        this.descript = {};
        console.warn("descript.txt is not found");
      }
      keys = Object.keys(this.directory);
      hits = keys.filter(function(name) {
        return /surfaces\d*\.txt$/.test(name);
      });
      if (hits.length === 0) {
        console.warn("surfaces.txt is not found");
        surfaces = {
          "surfaces": {}
        };
      } else {
        surfaces = hits.reduce(((function(_this) {
          return function(obj, name) {
            var _srfs;
            _srfs = Shell.parseSurfaces(Util.convert(_this.directory[name]));
            return $.extend(true, obj, _srfs);
          };
        })(this)), {});
      }
      prm = Promise.resolve(surfaces);
      prm = prm.then(Shell.mergeSurfacesAndSurfacesFiles(this.directory));
      prm = prm.then(Shell.loadSurfaces(this.directory));
      prm = prm.then(Shell.loadElements(this.directory));
      prm = prm.then(Shell.createBases(this.directory));
      prm = prm.then((function(_this) {
        return function(surfaces) {
          _this.surfaces = surfaces;
          _this.directory = null;
          return _this;
        };
      })(this));
      prm = prm["catch"](function(err) {
        console.error(err);
        err.message && console.error(err.message);
        err.stack && console.error(err.stack);
        throw err;
      });
      return prm;
    };

    Shell.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var _surfaceId, hit, keys, ref, ref1, srfs, type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (Array.isArray((ref = this.surfaces.aliases) != null ? (ref1 = ref[type]) != null ? ref1[surfaceId] : void 0 : void 0)) {
        _surfaceId = SurfaceUtil.choice(this.surfaces.aliases[type][surfaceId]);
      } else {
        _surfaceId = surfaceId;
      }
      srfs = this.surfaces.surfaces;
      keys = Object.keys(srfs);
      hit = keys.filter(function(name) {
        return srfs[name].is === _surfaceId;
      })[0];
      if (!hit) {
        return null;
      }
      return new Surface(canvas, scopeId, hit, this.surfaces);
    };

    Shell.createBases = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var keys, srfs;
          srfs = surfaces.surfaces;
          keys = Object.keys(srfs);
          keys.forEach(function(name) {
            var _baseSurface, _keys, baseSurface, elms, mapped, ref, sortedElms, srfutil;
            sortedElms = [];
            if (!!srfs[name].elements) {
              elms = srfs[name].elements;
              _keys = Object.keys(elms);
              mapped = _keys.map(function(key) {
                return {
                  is: elms[key].is,
                  x: elms[key].x,
                  y: elms[key].y,
                  canvas: elms[key].canvas,
                  type: elms[key].type
                };
              });
              sortedElms = mapped.sort(function(elmA, elmB) {
                if (elmA.is > elmB.is) {
                  return 1;
                } else {
                  return -1;
                }
              });
              delete srfs[name].elements;
            }
            baseSurface = srfs[name].baseSurface || ((ref = sortedElms[0]) != null ? ref.canvas : void 0);
            if (!baseSurface) {
              console.warn(name + " does not have base surface");
              return;
            }
            _baseSurface = SurfaceUtil.copy(baseSurface);
            srfutil = new SurfaceUtil(_baseSurface);
            srfutil.composeElements(sortedElms);
            return srfs[name].baseSurface = _baseSurface;
          });
          return resolve(surfaces);
        });
      };
    };

    Shell.loadElements = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var hits, keys, prm, promises, srfs;
          srfs = surfaces.surfaces;
          keys = Object.keys(srfs);
          hits = keys.filter(function(name) {
            return !!srfs[name].elements;
          });
          promises = [];
          hits.forEach(function(srfName) {
            var elmKeys;
            elmKeys = Object.keys(srfs[srfName].elements);
            return elmKeys.forEach(function(elmName) {
              var _prm, elm, file, filename, path, type, x, y;
              elm = srfs[srfName].elements[elmName];
              type = elm.type, file = elm.file, x = elm.x, y = elm.y;
              keys = Object.keys(directory);
              path = keys.filter(function(path) {
                var a, b;
                a = path.toLowerCase();
                b = file.toLowerCase();
                if (a === b) {
                  return true;
                }
                if (a === (b + ".png").toLowerCase()) {
                  console.warn("element file " + b + " need '.png' extension");
                  return true;
                }
                return false;
              })[0];
              if (!path) {
                console.warn("element " + file + " is not found");
                elm.canvas = document.createElement("canvas");
                elm.canvas.width = 1;
                elm.canvas.height = 1;
                return;
              }
              if (!!directory[path]) {
                filename = path;
              } else if (!!directory[path + ".png"]) {
                filename = path + ".png";
              } else {
                filename = null;
              }
              if (!!filename) {
                _prm = Promise.resolve(filename);
                _prm = _prm.then(Shell.loadPNGAndPNA(directory));
                _prm = _prm.then(function(cnv) {
                  return elm.canvas = cnv;
                });
                _prm = _prm["catch"](reject);
                return promises.push(_prm);
              }
            });
          });
          prm = Promise.all(promises);
          prm = prm.then(function() {
            return resolve(surfaces);
          });
          prm = prm["catch"](reject);
          return prm;
        });
      };
    };

    Shell.loadSurfaces = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var hits, keys, prm, promises, srfs;
          srfs = surfaces.surfaces;
          keys = Object.keys(srfs);
          hits = keys.filter(function(name) {
            return !!srfs[name].filename;
          });
          promises = hits.map(function(name) {
            var _prm;
            _prm = Promise.resolve(srfs[name].filename);
            _prm = _prm.then(Shell.loadPNGAndPNA(directory));
            _prm = _prm.then(function(cnv) {
              return srfs[name].baseSurface = cnv;
            });
            _prm = _prm["catch"](reject);
            return _prm;
          });
          prm = Promise.all(promises);
          prm = prm.then(function() {
            return resolve(surfaces);
          });
          prm = prm["catch"](reject);
          return prm;
        });
      };
    };

    Shell.loadPNGAndPNA = function(directory) {
      return function(filename) {
        return new Promise(function(resolve, reject) {
          var buffer, url;
          buffer = directory[filename];
          url = URL.createObjectURL(new Blob([buffer], {
            type: "image/png"
          }));
          return SurfaceUtil.loadImage(url, function(err, img) {
            var cnv, pnafilename;
            if (!!err) {
              URL.revokeObjectURL(url);
              return reject(err);
            } else {
              URL.revokeObjectURL(url);
              pnafilename = filename.replace(/\.png$/i, ".pna");
              cnv = SurfaceUtil.transImage(img);
              if (!directory[pnafilename]) {
                return resolve(SurfaceUtil.transImage(img));
              } else {
                buffer = directory[pnafilename];
                url = URL.createObjectURL(new Blob([buffer], {
                  type: "image/png"
                }));
                return SurfaceUtil.loadImage(url, function(err, pnaimg) {
                  var pnacnv;
                  if (!!err) {
                    URL.revokeObjectURL(url);
                    console.warn("cannot read pna file", filename, pnafilename, err);
                    return resolve(SurfaceUtil.transImage(img));
                  } else {
                    cnv = SurfaceUtil.copy(img);
                    pnacnv = SurfaceUtil.copy(pnaimg);
                    URL.revokeObjectURL(url);
                    return resolve(SurfaceUtil.pna(cnv, pnacnv));
                  }
                });
              }
            }
          });
        });
      };
    };

    Shell.mergeSurfacesAndSurfacesFiles = function(directory) {
      return function(surfaces) {
        return new Promise(function(resolve, reject) {
          var hits, keys, srfs, tuples;
          srfs = surfaces.surfaces;
          keys = Object.keys(directory);
          hits = keys.filter(function(filename) {
            return /^surface\d+\.png$/i.test(filename);
          });
          tuples = hits.map(function(filename) {
            return [Number((/^surface(\d+)\.png$/i.exec(filename) || ["", "-1"])[1]), filename];
          });
          tuples.forEach(function(arg) {
            var filename, n, name;
            n = arg[0], filename = arg[1];
            name = Object.keys(srfs).filter(function(name) {
              return srfs[name].is === n;
            })[0];
            name = name || "surface" + n;
            srfs[name] = srfs[name] || {
              is: n
            };
            srfs[name].filename = filename;
            srfs[name].baseSurface = document.createElement("canvas");
            srfs[name].baseSurface.width = 1;
            return srfs[name].baseSurface.height = 1;
          });
          return resolve(surfaces);
        });
      };
    };

    Shell.parseSurfaces = function(text) {
      var keys, srfs, surfaces;
      surfaces = SurfacesTxt2Yaml.txt_to_data(text, {
        compatible: 'ssp-lazy'
      });
      surfaces.surfaces = surfaces.surfaces || {};
      srfs = surfaces.surfaces;
      keys = Object.keys(srfs);
      surfaces.surfaces = keys.reduce((function(obj, name) {
        if (typeof srfs[name].is !== "undefined") {
          obj[name] = srfs[name];
        }
        if (Array.isArray(srfs[name].base)) {
          srfs[name].base.forEach(function(key) {
            return $.extend(true, srfs[name], srfs[key]);
          });
          delete srfs[name].base;
        }
        return obj;
      }), {});
      return surfaces;
    };

    return Shell;

  })();

}).call(this);
