// Generated by CoffeeScript 1.9.2
(function() {
  cuttlebone.Balloon = (function() {
    function Balloon(directory) {
      this.directory = directory;
      this.descript = null;
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function() {
      var prm;
      if (!!this.directory["descript.txt"]) {
        this.descript = cuttlebone.Util.parseDescript(cuttlebone.Util.convert(this.directory["descript.txt"]));
      } else {
        this.descript = {};
        console.warn("descript.txt is not found");
      }
      prm = Promise.resolve(this.balloons);
      prm = prm.then(Balloon.loadBalloonSurfaces(this.directory));
      prm = prm.then(Balloon.loadBalloonDescripts(this.directory, this.descript));
      prm = prm.then((function(_this) {
        return function(balloons) {
          _this.balloons = balloons;
          _this.directory = null;
          return _this;
        };
      })(this));
      prm = prm["catch"](function(err) {
        console.error(err);
        err.message && console.error(err.message);
        err.stack && console.error(err.stack);
        throw err;
      });
      return prm;
    };

    Balloon.prototype.attachSurface = function(canvas, scopeId, surfaceId) {
      var type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (this.balloons[type][surfaceId] == null) {
        return null;
      }
      return new cuttlebone.BalloonSurface(canvas, scopeId, this.balloons[type][surfaceId], this.balloons);
    };

    Balloon.loadBalloonDescripts = function(directory, descript) {
      return function(balloons) {
        return new Promise(function(resolve, reject) {
          var hits, keys;
          keys = Object.keys(directory);
          hits = keys.filter(function(filepath) {
            return /balloon([sk])(\d+)s\.txt$/.test(filepath);
          });
          hits.forEach(function(filepath) {
            var __, _descript, buffer, n, ref, type;
            buffer = directory[filepath];
            _descript = cuttlebone.Util.parseDescript(cuttlebone.Util.convert(buffer));
            ref = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)].descript = $.extend(true, _descript, descript);
              case "k":
                return balloons["kero"][Number(n)].descript = $.extend(true, _descript, descript);
            }
          });
          return resolve(balloons);
        });
      };
    };

    Balloon.loadBalloonSurfaces = function(directory) {
      return function(balloons) {
        var hits, keys, promises;
        keys = Object.keys(directory);
        hits = keys.filter(function(filepath) {
          return /[^\/]+\.png$/.test(filepath);
        });
        promises = hits.map(function(filepath) {
          return new Promise(function(resolve, reject) {
            var buffer, url;
            buffer = directory[filepath];
            url = URL.createObjectURL(new Blob([buffer], {
              type: "image/png"
            }));
            return cuttlebone.SurfaceUtil.fetchImageFromURL(url).then(function(img) {
              return [null, img];
            })["catch"](function(err) {
              return [err, null];
            }).then(function(arg) {
              var __, err, img, n, ref, ref1, ref2, rndr, type;
              err = arg[0], img = arg[1];
              if (!!err) {
                return reject(err);
              }
              URL.revokeObjectURL(url);
              if (!!err) {
                return reject(err);
              }
              rndr = new cuttlebone.SurfaceRender(cuttlebone.SurfaceUtil.copy(img));
              rndr.chromakey();
              if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
                ref = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
                switch (type) {
                  case "s":
                    balloons["sakura"][Number(n)] = {
                      canvas: rndr.cnv
                    };
                    break;
                  case "k":
                    balloons["kero"][Number(n)] = {
                      canvas: rndr.cnv
                    };
                    break;
                  case "c":
                    balloons["communicate"][Number(n)] = {
                      canvas: rndr.cnv
                    };
                }
              } else if (/^online(\d+)\.png$/.test(filepath)) {
                ref1 = /^online(\d+)\.png$/.exec(filepath), __ = ref1[0], n = ref1[1];
                balloons["online"][Number(n)] = {
                  canvas: rndr.cnv
                };
              } else if (/^arrow(\d+)\.png$/.test(filepath)) {
                ref2 = /^arrow(\d+)\.png$/.exec(filepath), __ = ref2[0], n = ref2[1];
                balloons["arrow"][Number(n)] = {
                  canvas: rndr.cnv
                };
              } else if (/^sstp\.png$/.test(filepath)) {
                balloons["sstp"] = {
                  canvas: rndr.cnv
                };
              } else if (/^thumbnail\.png$/.test(filepath)) {
                balloons["thumbnail"] = {
                  canvas: rndr.cnv
                };
              }
              return resolve();
            });
          });
        });
        return new Promise(function(resolve, reject) {
          return Promise.all(promises).then(function() {
            return resolve(balloons);
          });
        });
      };
    };

    return Balloon;

  })();

}).call(this);
